<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Euler Problem #2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
        }
        code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 4px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .solution {
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        .addenda {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Project Euler Problem #2</h1>
    
    <h2>Problem Statement:</h2>
    <p>
        Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
        <br>
        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        <br>
        By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    </p>

    <div class="solution">
        <h2>Solution:</h2>
        <p>
            As always, it helps to restate the problem. We want to find the sum of all even Fibonacci numbers less than or equal to four million. The general formula for Fibonacci numbers is:
            <br>
            <em>F<sub>i</sub> = F<sub>i-2</sub> + F<sub>iâˆ’1</sub></em>
        </p>

        <p>Breaking it down, we have two sub-problems:</p>
        <ol>
            <li>Generate the sequence of even Fibonacci numbers less than or equal to four million.</li>
            <li>Find their sum.</li>
        </ol>

        <p>There's a recursive solution that is initially tempting</p>
        <pre><code>def fibonacci(n):
  if n == 0:
    return 0
  if n == 1:
    return 1
  return fib(n-2) + fib(n-1)</code></pre>

        <p>
            However, don't be so hasty. Expanding out this solution reveals that its time complexity is completely unacceptable. For example, if we wanted to the calculate <code>fibonacci(8)</code>, this function would perform the following work:
        </p>
        <pre><code>fibonacci(8) = fibonacci(6) + fibonacci(7)
fibonacci(7) = fibonacci(5) + fibonacci(6)
fibonacci(6) = fibonacci(4) + fibonacci(5)
fibonacci(5) = fibonacci(3) + fibonacci(4)
fibonacci(4) = fibonacci(2) + fibonacci(3)
fibonacci(3) = fibonacci(1) + fibonacci(2)
fibonacci(2) = fibonacci(0) + fibonacci(1)
fibonacci(1) = 1</code></pre>

        <p>
            For each non-base case call, we perform <em>two</em> recursive calls. The first call produces 2 calls, which each produce 2 more calls, making 4. Each of <em>those</em> produce <em>2 more calls</em>, making 8. Once we're <em>k</em> levels down, that's <em>2<sup>k</sup></em> non-recursive calls. Exponential growth. Yikes. Even worse, notice how we calculate values like <code>fibonacci(5)</code> and <code>fibonacci(4)</code> multiple times? We're not even doing <em>useful</em> exponential work, but just recalculating the same values over and over again.
        </p>

        <p>
            If you're dead-set on recursive solutions and know a thing or two about computer science, you'll know that this is a classic dynamic programming problem. We could trade off time for space complexity using memoization to avoid recalculating values. But I hate recursion and don't know much about dynamic programming, so screw that.
        </p>

        <p>Every recursion can be re-written as an iteration. To generate all Fibonacci numbers less than <em>n</em>, it looks something like this:</p>
        <pre><code>a, b = 0, 1
while a < n:
  print(a)
  a, b = b, a+b

# For n = 500, we get the following output
# 0
# 1
# 1
# 2
# 3
# 5
# 8
# 13
# 21
# 34
# 55
# 89
# 144
# 233
# 377

# To make it only print even, we simply modify it like so:
a, b = 0, 1
while a < n:
  if a % 2 == 0:
    print(a)
  a, b = b, a+b</code></pre>

        <p>
            That's basically the entire problem. All we have to do to turn this into a solution is replace print with a running total and wrap it in a neat little bow.
        </p>

        <pre><code>def calculate_fibonacci_sum(n):
    total = 0
    a, b = 0, 1
    while a < n:
        if (a % 2 == 0):
            total += a
        a, b = b, a + b
    return total</code></pre>

        <p>
            Better yet, this implementation improves on our exponential recursive solution by only looping through Fibonacci numbers instead of recalculating them repeatedly. Because Fibonacci numbers grow exponentially, we only need a few steps to reach <em>n</em>. Instead of checking every number up to <em>n</em>, we skip ahead quickly, reducing the number of iterations to about log(n). The time complexity of this solution is <code>O(log(n))</code> and it's space complexity is <code>O(1)</code>.
        </p>
    </div>

    <div class="addenda">
        <h2>Addenda & Future Expansion</h2>
        <ul>
            <li>Implementation of dynamic programming solution.</li>
            <li>Using basic proofs, we can show that the Fibonacci sequence actually follows a defined pattern of odd and even numbers.
                <ul>
                    <li><strong>Even + Even = Even</strong>
                        <br>An even number is any integer divisible by 2 e.g. 2<em>n</em> for an integer <em>n</em>. The above statement is true because 2<em>n</em> + 2<em>m</em> = 2(<em>n</em> + <em>m</em>) for any two integers <em>n</em> and <em>m</em>. The sum of any two integers is another integer <em>k</em>, making this equal to 2k and therefore even.
                    </li>
                    <li><strong>Odd + Odd = Even</strong>
                        <br>The formula for an odd number is 2<em>n</em>-1. For any two integers <em>n</em> and <em>m</em>, this would be 2<em>n</em>-1 + 2<em>m</em>-1 = 2<em>n</em> + 2<em>m</em> - 2 = 2(<em>n</em> + <em>m</em> - 1). Hence, an even number.
                    </li>
                    <li><strong>Odd + Even = Odd</strong>
                        <br>2<em>n</em> + 2<em>m</em>-1 = 2(<em>n</em> + <em>m</em>) - 1. The sum of any two integers <em>n</em> and <em>m</em> is an integer <em>k</em>, making this equivalent to 2<em>k</em>-1, hence odd.
                    </li>
                    <li>Starting at 0 and 1, we have even and odd. Adding them together gives us 1, an odd number. The sequence so far is thus
                        <br><em>even, odd, odd</em>
                    </li>
                    <li>Adding 1 + 1 is 2, therefore even. 1 + 2 is 3, odd. 2 + 3 is 5, odd.
                        <br><em>even, odd, odd, even, odd, odd</em>
                        <br>See the pattern?
                    </li>
                    <li>If we look at the original example given by Project Euler starting at 1 and 2, we see a similar pattern
                        <br><em>odd, even, odd, odd, even, odd, odd, even, odd, odd</em>
                        <br>Adding another 1 to the beginning doesn't break the sequence and completes the pattern. Write another solution that takes advantage of this.
                    </li>
                </ul>
            </li>
        </ul>
    </div>
</body>
</html>